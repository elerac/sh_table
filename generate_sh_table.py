# Generate a table of spherical harmonics
from pathlib import Path
from sympy import *


def P(l, m, x):
    """https://en.wikipedia.org/wiki/Associated_Legendre_polynomials"""
    if m == 0:
        return legendre(l, x)
    elif m > 0:
        return (-1) ** m * sqrt(1 - x**2) ** m * diff(legendre(l, x), x, m)
    else:
        m = -m
        return (-1) ** m * factorial(l - m) / factorial(l + m) * P(l, m, x)


def Y(l, m, theta, phi):
    """https://en.wikipedia.org/wiki/Spherical_harmonics#Orthogonality_and_normalization"""

    cos_theta = symbols("cos_theta", real=True)  # temporary variable for cos(theta)
    Y_l_m = sqrt((2 * l + 1) / (4 * pi) * factorial(l - m) / factorial(l + m)) * P(l, m, cos_theta) * exp(I * m * phi)

    Y_l_m = Y_l_m.subs(cos_theta, cos(theta))

    return Y_l_m


def Y_real(l, m, theta, phi):
    """https://en.wikipedia.org/wiki/Spherical_harmonics#Real_form"""
    if m == 0:
        return Y(l, m, theta, phi)
    elif m > 0:
        return (Y(l, -m, theta, phi) + (-1) ** m * Y(l, m, theta, phi)) / sqrt(2)
    else:
        return I * (Y(l, m, theta, phi) - (-1) ** m * Y(l, -m, theta, phi)) / sqrt(2)


def main():
    # Maximum level
    levels = 10

    # for python code generation
    export_l0 = True
    filename_py = f"sh_encoder_levels{levels}.py"

    # symbols
    x, y, z = symbols("x y z", real=True)
    r = symbols("r", real=True, positive=True)
    theta, phi = symbols("theta phi", real=True)

    expressions = {}
    for l in range(levels):
        for m in range(-l, l + 1):
            Y_l_m_real = Y_real(l, m, theta, phi)

            # Replace [theta, phi] with [x, y, z]
            # exp(I * phi) = (x + I * y) / sqrt(x**2 + y**2)
            # phi = atan2(y, x)
            # theta = acos(z / r)
            Y_l_m_real = Y_l_m_real.subs(exp(I * phi), (x + I * y) / sqrt(x**2 + y**2))
            Y_l_m_real = Y_l_m_real.subs(phi, atan2(y, x))
            Y_l_m_real = Y_l_m_real.subs(theta, acos(z / sqrt(x**2 + y**2 + z**2)))

            # Replace x**2 + y**2 + z**2 with r**2
            Y_l_m_real = Y_l_m_real.subs(x**2 + y**2 + z**2, r**2).factor()
            Y_l_m_real = Y_l_m_real.subs(x**2, r**2 - y**2 - z**2).factor()
            Y_l_m_real = Y_l_m_real.subs(y**2, r**2 - x**2 - z**2).factor()
            Y_l_m_real = Y_l_m_real.subs(z**2, r**2 - x**2 - y**2).factor()

            # Get real part
            Y_l_m_real = re(Y_l_m_real)

            Y_l_m_real = Y_l_m_real.simplify()

            expressions[(l, m)] = Y_l_m_real

            if m >= 0:
                print(f"l={l}, m={m}  -> {Y_l_m_real}")
            else:
                print(f"l={l}, m={m} -> {Y_l_m_real}")

        print()

    # Modify for python code
    xx, yy, zz = symbols("xx yy zz", real=True, positive=True)
    for l in range(levels):
        for m in range(-l, l + 1):
            Y_l_m_real = expressions[(l, m)]

            # Use xx, yy, zz
            Y_l_m_real = Y_l_m_real.expand()
            Y_l_m_real = Y_l_m_real.subs(x**2, xx)
            Y_l_m_real = Y_l_m_real.subs(y**2, yy)
            Y_l_m_real = Y_l_m_real.subs(z**2, zz)

            # r = 1
            Y_l_m_real = Y_l_m_real.subs(r, 1)

            Y_l_m_real = Y_l_m_real.simplify()

            # Evaluate sqrt values
            Y_l_m_real = Y_l_m_real.evalf()

            # Replace to new one
            expressions[(l, m)] = Y_l_m_real

    # Export Python code
    s = ""
    s += "# This code is generated by generate_sh_table.py\n"
    s += "# The function `components_from_spherical_harmonics` references the code of nerfstudio (https://github.com/nerfstudio-project/nerfstudio) `nerfstudio/utils/math.py`\n"
    s += f"\n"
    s += f"import torch\n"
    s += f"import matplotlib.pyplot as plt\n"
    s += f"\n"
    s += f"\n"
    # Function
    s += f"def components_from_spherical_harmonics(levels: int, directions: torch.Tensor) -> torch.Tensor:\n"
    s += f"    num_components = levels**2\n" if export_l0 else f"    num_components = levels**2 - 1\n"
    s += f"    components = torch.empty((*directions.shape[:-1], num_components), device=directions.device)\n"
    s += f"\n"
    s += f'    assert 1 < levels <= {levels}, f"SH levels must be in [1,{levels}], got {{levels}}"\n'
    s += f'    assert directions.shape[-1] == 3, f"Direction input should have three dimensions. Got {{directions.shape[-1]}}"\n'
    s += f"\n"
    s += f"    x = directions[..., 0]\n"
    s += f"    y = directions[..., 1]\n"
    s += f"    z = directions[..., 2]\n"
    s += f"\n"
    s += f"    xx = x**2\n"
    s += f"    yy = y**2\n"
    s += f"    zz = z**2\n"
    s += f"\n"
    l_start = 0 if export_l0 else 1
    if not export_l0:
        s += f"    # l0 is omitted\n"

    i = 0
    for l in range(l_start, levels):
        s += f"    # l{l}\n"
        s += f"    if levels > {l}:\n"
        for m in range(-l, l + 1):
            s += f"        components[..., {i}] = {expressions[(l, m)]}\n"
            i += 1
        s += f"\n"
    s += f"\n"
    s += f"    return components\n"
    s += f"\n"
    s += f"\n"
    # Main
    s += f"def main():\n"
    s += f"    levels = {levels}\n"
    s += f"\n"
    s += f"    height = 100\n"
    s += f"    width = 150\n"
    s += f"\n"
    s += f"    theta = torch.linspace(-torch.pi, torch.pi, width)\n"
    s += f"    phi = torch.linspace(0, torch.pi, height)\n"
    s += f"    [theta, phi] = torch.meshgrid(theta, phi, indexing='xy')\n"
    s += f"\n"
    s += f"    directions = torch.stack([torch.cos(theta) * torch.sin(phi), torch.sin(theta) * torch.sin(phi), torch.cos(phi)], dim=-1)\n"
    s += f"\n"
    s += f"    encoded_values = components_from_spherical_harmonics(levels, directions)\n"
    s += f"    encoded_values = torch.moveaxis(encoded_values, 2, 0)\n"
    s += f"\n"
    s += f"    max_number_images = (levels - 1) * 2 + 1\n"
    s += f"    fig = plt.figure(figsize=(max_number_images, levels))\n"
    s += f"    axes = fig.subplots(levels, max_number_images)\n"
    s += f"    for l in range(levels):\n"
    s += f"        i0 = l**2\n" if export_l0 else f"        i0 = l**2 - 1\n"
    s += f"        i1 = (l + 1) ** 2\n" if export_l0 else f"        i1 = (l + 1) ** 2 - 1\n"
    s += f"        images = encoded_values[i0:i1]\n"
    s += f"        images = images.reshape((-1, height, width))\n"
    s += f"        images = images.detach().cpu().numpy()\n"
    s += f"\n"
    s += f"        # subtitles\n"
    s += f"        axes[l, 0].set_title(f'Level: {{l+1}}')\n"
    s += f"\n"
    s += f"        # images\n"
    s += f"        num = len(images)\n"
    s += f"        for i in range(max_number_images):\n"
    s += f"            if 0 <= i < (max_number_images - num) // 2:\n"
    s += f"                axes[l, i].axis('off')\n"
    s += f"            elif (max_number_images - num) // 2 <= i < (max_number_images + num) // 2:\n"
    s += f"                axes[l, i].imshow(images[i - (max_number_images - num) // 2], cmap='plasma')\n"
    s += f"                axes[l, i].axis('off')\n"
    s += f"            else:\n"
    s += f"                axes[l, i].axis('off')\n"
    s += f"\n"
    s += f"    plt.savefig('docs/{Path(filename_py).stem}.pdf', bbox_inches='tight')\n"
    s += f"    plt.show()\n"
    s += f"\n"
    s += f"\n"
    s += f"if __name__ == '__main__':\n"
    s += f"    main()\n"

    # Apply black formatter if available
    try:
        import black

        s = black.format_str(s, mode=black.Mode(line_length=1000))
    except ImportError:
        pass

    with open(filename_py, "w") as f:
        f.write(s)


if __name__ == "__main__":
    main()
